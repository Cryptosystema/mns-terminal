<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>MNS Terminal — mns.com.ge</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    html, body {
      margin: 0;
      padding: 0;
      background: #000;
      color: #00ff66;
      font-family: "Courier New", monospace;
      height: 100%;
      overflow: hidden;
    }
    #terminal {
      box-sizing: border-box;
      padding: 20px;
      height: 100%;
      display: flex;
      flex-direction: column;
      justify-content: flex-start;
      white-space: pre;
    }
    #nav {
      font-weight: bold;
      margin-bottom: 8px;
      letter-spacing: 0.5px;
    }
    #status {
      opacity: 0.7;
      margin-bottom: 20px;
      letter-spacing: 0.5px;
      animation: heartbeat 4s ease-in-out infinite;
    }
    @keyframes heartbeat {
      0%, 100% { opacity: 0.7; }
      50% { opacity: 0.85; }
    }
  </style>
</head>
<body>
  <div id="terminal">
    <div id="nav"></div>
    <div id="status"></div>
  </div>

  <script>
    /* =========================
       Phase 15.2 — Sanitization Stress & Edge Case Hardening
       Market Navigation System (MNS)
       Target: mns.com.ge
       Mode: Defense-in-Depth, Fail-Closed, Fuzz-Hardened
       ========================= */

    "use strict";

    /* ---- CRYPTOGRAPHIC ANCHORS (IMMUTABLE) ---- */
    const PUB_KEY_BASE64 = "REPLACE_WITH_BASE64_44_CHARS";
    const MAX_SKEW_MS = 30000;

    /* ---- TIER 0 STATIC NAV PACKET (IMMUTABLE) ---- */
    const STATIC_NAV_PACKET = Object.freeze({
      regime: "COMPRESSION",
      risk: "NORMAL",
      confidence: "MEDIUM",
      status: "LIVE",
      scope: "PUBLIC"
    });

    /* ---- REGIME CATALOG (IMMUTABLE) ---- */
    const REGIMES = Object.freeze([
      "ACCUMULATION",
      "EXPANSION",
      "DISLOCATION",
      "EXHAUSTION",
      "COMPRESSION"
    ]);

    /* ---- RISK LEVELS (IMMUTABLE) ---- */
    const RISK_LEVELS = Object.freeze([
      "LOW",
      "NORMAL",
      "HIGH"
    ]);

    /* ---- CONFIDENCE LEVELS (IMMUTABLE) ---- */
    const CONFIDENCE_LEVELS = Object.freeze([
      "LOW",
      "MEDIUM",
      "HIGH"
    ]);

    /* ---- BIAS LEVELS (TIER 1, IMMUTABLE) ---- */
    const BIAS_LEVELS = Object.freeze([
      "BULLISH",
      "BEARISH",
      "NEUTRAL"
    ]);

    /* ---- STABILITY LEVELS (TIER 1, IMMUTABLE) ---- */
    const STABILITY_LEVELS = Object.freeze([
      "FORMING",
      "MATURE",
      "WEAKENING"
    ]);

    /* ---- REENTRANCY LOCK (PHASE 15.2) ---- */
    let validationEpoch = 0;

    /* ---- DOM REFERENCES ---- */
    const navEl = document.getElementById("nav");
    const statusEl = document.getElementById("status");

    /* ---- PHASE 15.1: CRYPTOGRAPHIC VALIDATION (Web Crypto API) ---- */

    /* Base64 → Uint8Array (Phase 15.2: Normalized, Strict) */
    function decodeBase64ToUint8(base64) {
      try {
        // Phase 15.2: Normalize input (trim, remove whitespace)
        if (typeof base64 !== 'string') {
          throw new Error("Not a string");
        }
        const normalized = base64.replace(/\s/g, '').trim();
        if (normalized.length === 0) {
          throw new Error("Empty Base64");
        }
        // Strict length check (Ed25519 signature = 64 bytes = 88 Base64 chars with padding)
        // Public key = 32 bytes = 44 Base64 chars
        if (normalized.length < 4) {
          throw new Error("Base64 too short");
        }
        
        const binaryString = atob(normalized);
        const len = binaryString.length;
        const bytes = new Uint8Array(len);
        for (let i = 0; i < len; i++) {
          bytes[i] = binaryString.charCodeAt(i);
        }
        return bytes;
      } catch (err) {
        throw new Error("Invalid Base64");
      }
    }

    /* Import Ed25519 Public Key */
    async function importPublicKey(base64) {
      try {
        const keyData = decodeBase64ToUint8(base64);
        return await crypto.subtle.importKey(
          "raw",
          keyData,
          {
            name: "Ed25519",
            namedCurve: "Ed25519"
          },
          false,
          ["verify"]
        );
      } catch (err) {
        throw new Error("Key import failed");
      }
    }

    /* Verify Ed25519 Signature */
    async function verifySignature(payloadUint8, signatureUint8, publicKey) {
      try {
        return await crypto.subtle.verify(
          "Ed25519",
          publicKey,
          signatureUint8,
          payloadUint8
        );
      } catch (err) {
        return false;
      }
    }

    /* Time Freshness Check (Phase 15.2: Strict ISO 8601) */
    function isFresh(issuedAtISO) {
      try {
        // Type guard
        if (typeof issuedAtISO !== 'string') return false;
        
        // Strict ISO 8601 format check (basic pattern)
        const iso8601Pattern = /^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}(\.\d{3})?Z?$/;
        if (!iso8601Pattern.test(issuedAtISO)) return false;
        
        const issued = Date.parse(issuedAtISO);
        if (isNaN(issued)) return false;
        
        // Sanity check: not too far in past/future
        const now = Date.now();
        const skew = Math.abs(now - issued);
        
        // Reject if timestamp is unreasonable (> 1 year in past/future)
        const maxReasonable = 365 * 24 * 60 * 60 * 1000;
        if (skew > maxReasonable) return false;
        
        return skew <= MAX_SKEW_MS;
      } catch (err) {
        return false;
      }
    }

    /* Structural Gate (Phase 15.2: Strict Whitelist + Type Enforcement) */
    function structuralGate(packet) {
      try {
        // Null/undefined check
        if (!packet || typeof packet !== 'object') return false;
        
        // Prototype pollution defense
        if (packet.__proto__ !== Object.prototype && packet.__proto__ !== null) {
          return false;
        }
        
        // Whitelist: allowed top-level keys only
        const allowedKeys = ['nav', 'meta', 'status'];
        const packetKeys = Object.keys(packet);
        for (const key of packetKeys) {
          if (!allowedKeys.includes(key)) return false;
        }
        
        // Nav validation
        if (!packet.nav || typeof packet.nav !== 'object') return false;
        
        // Tier 1 markers present?
        const hasTier1Fields = packet.nav.bias || packet.nav.stability;
        
        // If Tier 1 fields present, require signature
        if (hasTier1Fields && !packet.meta?.signature) {
          return false;
        }

        // If signature present, validate tier
        if (packet.meta?.signature && packet.meta?.tier !== 1) {
          return false;
        }

        // Required fields for Tier 1
        if (packet.meta?.tier === 1) {
          // Nav field type checks
          if (typeof packet.nav.regime !== 'string' || !REGIMES.includes(packet.nav.regime)) return false;
          if (typeof packet.nav.risk !== 'string' || !RISK_LEVELS.includes(packet.nav.risk)) return false;
          if (typeof packet.nav.confidence !== 'string' || !CONFIDENCE_LEVELS.includes(packet.nav.confidence)) return false;
          if (typeof packet.nav.bias !== 'string' || !BIAS_LEVELS.includes(packet.nav.bias)) return false;
          if (typeof packet.nav.stability !== 'string' || !STABILITY_LEVELS.includes(packet.nav.stability)) return false;
          
          // Meta validation
          if (!packet.meta || typeof packet.meta !== 'object') return false;
          if (typeof packet.meta.issued_at !== 'string') return false;
          if (typeof packet.meta.signature !== 'string') return false;
          if (typeof packet.meta.tier !== 'number' || packet.meta.tier !== 1) return false;
          
          // Whitelist nav fields for Tier 1
          const allowedNavKeys = ['regime', 'risk', 'confidence', 'bias', 'stability'];
          const navKeys = Object.keys(packet.nav);
          for (const key of navKeys) {
            if (!allowedNavKeys.includes(key)) return false;
          }
          
          // Whitelist meta fields
          const allowedMetaKeys = ['tier', 'issued_at', 'signature'];
          const metaKeys = Object.keys(packet.meta);
          for (const key of metaKeys) {
            if (!allowedMetaKeys.includes(key)) return false;
          }
        }

        return true;
      } catch (err) {
        return false;
      }
    }

    /* Build Canonical Payload (Phase 15.2: Strict Order + Type Guards) */
    function buildCanonicalPayload(packet) {
      try {
        // Strict type validation
        if (typeof packet.meta.tier !== 'number') throw new Error("Invalid tier type");
        if (typeof packet.nav.regime !== 'string') throw new Error("Invalid regime type");
        if (typeof packet.nav.risk !== 'string') throw new Error("Invalid risk type");
        if (typeof packet.nav.confidence !== 'string') throw new Error("Invalid confidence type");
        if (typeof packet.nav.bias !== 'string') throw new Error("Invalid bias type");
        if (typeof packet.nav.stability !== 'string') throw new Error("Invalid stability type");
        if (typeof packet.meta.issued_at !== 'string') throw new Error("Invalid timestamp type");
        
        // No NaN, Infinity, null, undefined in strings
        const fields = [
          packet.nav.regime,
          packet.nav.risk,
          packet.nav.confidence,
          packet.nav.bias,
          packet.nav.stability,
          packet.meta.issued_at
        ];
        
        for (const field of fields) {
          if (field.includes('\0') || field.includes('\uFFFD')) {
            throw new Error("Invalid characters in payload");
          }
        }
        
        const payload = 
          String(packet.meta.tier) +
          packet.nav.regime +
          packet.nav.risk +
          packet.nav.confidence +
          packet.nav.bias +
          packet.nav.stability +
          packet.meta.issued_at;
        
        const encoder = new TextEncoder();
        return encoder.encode(payload);
      } catch (err) {
        throw new Error("Payload build failed");
      }
    }

    /* Tier 1 Validation Pipeline (Phase 15.2: Reentrancy-Safe, Hardened) */
    async function validateTier1(packet, epoch) {
      try {
        // Phase 15.2: Epoch check (prevent stale validation results)
        if (epoch !== validationEpoch) {
          return false;
        }
        
        // Step A: Structural gate
        if (!structuralGate(packet)) {
          return false;
        }
        
        // Epoch recheck (async boundary)
        if (epoch !== validationEpoch) {
          return false;
        }

        // Step B: Freshness check
        if (!isFresh(packet.meta.issued_at)) {
          return false;
        }

        // Step C: Build canonical payload
        const payloadBytes = buildCanonicalPayload(packet);
        
        // Phase 15.2: Length sanity check
        if (payloadBytes.length === 0 || payloadBytes.length > 1024) {
          return false;
        }

        // Step D: Decode signature
        const signatureBytes = decodeBase64ToUint8(packet.meta.signature);
        
        // Phase 15.2: Ed25519 signature must be exactly 64 bytes
        if (signatureBytes.length !== 64) {
          return false;
        }
        
        // Epoch recheck (async boundary)
        if (epoch !== validationEpoch) {
          return false;
        }

        // Step E: Import public key (stateless per spec)
        const publicKey = await importPublicKey(PUB_KEY_BASE64);
        
        // Epoch recheck (async boundary)
        if (epoch !== validationEpoch) {
          return false;
        }

        // Step F: Verify signature
        const valid = await verifySignature(payloadBytes, signatureBytes, publicKey);
        
        // Final epoch check
        if (epoch !== validationEpoch) {
          return false;
        }

        return valid;

      } catch (err) {
        // Silent fail (no logs)
        return false;
      }
    }

    /* ---- PHASE 15.1: STATE SANITIZATION (Hard Reset) ---- */

    /* ---- PHASE 15.1: STATE SANITIZATION (Hard Reset) ---- */

    /* Global state holder (for potential future Tier 1 state) */
    let currentPacket = null;

    /* Sanitize to Tier 0 (Phase 15.2: Memory Hygiene, Zero-Reference) */
    function sanitizeToTier0() {
      try {
        // Phase 15.2: Increment epoch to invalidate in-flight validations
        validationEpoch++;
        
        // Physically remove Tier 1 artifacts
        currentPacket = null;
        
        // Clear any potential Tier 1 state from memory
        if (window.tier1State) {
          delete window.tier1State;
        }
        
        // Phase 15.2: Clear any cached crypto objects (defense-in-depth)
        if (window.cachedPublicKey) {
          delete window.cachedPublicKey;
        }
        
        // Phase 15.2: Zero out any temporary validation buffers
        if (window.validationBuffer) {
          delete window.validationBuffer;
        }

        // Reset to static Tier 0 packet (deep clone to prevent mutation)
        currentPacket = Object.freeze({
          regime: STATIC_NAV_PACKET.regime,
          risk: STATIC_NAV_PACKET.risk,
          confidence: STATIC_NAV_PACKET.confidence,
          status: STATIC_NAV_PACKET.status,
          scope: STATIC_NAV_PACKET.scope
        });

      } catch (err) {
        // Fail-safe: force reset
        validationEpoch++;
        currentPacket = null;
      }
    }

    /* ---- PHASE 15.1: PACKET INGESTION (Validation Integration) ---- */

    /* Update State (Phase 15.2: Reentrancy-Safe, Fail-Closed) */
    async function updateState(packet) {
      // Phase 15.2: Increment epoch (invalidate previous in-flight validations)
      const currentEpoch = ++validationEpoch;
      
      try {
        // Phase 15.2: Input sanitization (null/undefined/non-object)
        if (!packet || typeof packet !== 'object') {
          sanitizeToTier0();
          renderNAV(STATIC_NAV_PACKET);
          return;
        }
        
        // Phase 15.2: JSON sanity checks (detect NaN, Infinity, prototype pollution)
        const jsonStr = JSON.stringify(packet);
        if (jsonStr.includes('null') || jsonStr.includes('NaN') || jsonStr.includes('Infinity')) {
          sanitizeToTier0();
          renderNAV(STATIC_NAV_PACKET);
          return;
        }
        
        // Detect Tier 1 attempt
        const isTier1Attempt = packet?.meta?.tier === 1 || 
                               packet?.nav?.bias || 
                               packet?.nav?.stability;

        if (isTier1Attempt) {
          // Validate Tier 1 with epoch tracking
          const valid = await validateTier1(packet, currentEpoch);
          
          // Phase 15.2: Epoch check after async validation
          if (currentEpoch !== validationEpoch) {
            // Stale result, another updateState() was called
            return;
          }
          
          if (valid) {
            // Valid Tier 1 packet received
            // DO NOTHING VISUAL (Tier 1 UI not enabled yet)
            // Store for future use (Phase 15.3+)
            currentPacket = Object.freeze({
              nav: Object.freeze({...packet.nav}),
              meta: Object.freeze({...packet.meta}),
              status: packet.status ? Object.freeze({...packet.status}) : undefined
            });
            // No render changes
            return;
          } else {
            // Invalid Tier 1 → fail to Tier 0
            sanitizeToTier0();
            renderNAV(STATIC_NAV_PACKET);
            return;
          }
        }

        // Tier 0 path (normal)
        currentPacket = packet || STATIC_NAV_PACKET;
        renderNAV(currentPacket);

      } catch (err) {
        // Any error → fail-closed to Tier 0
        sanitizeToTier0();
        triggerFailSafe();
      }
    }

    /* ---- ARCHITECTURE: SANITIZE FOR TIER 0 (Deep Clone + Strip) ---- */
    function sanitizeForTier0(state) {
      try {
        // Deep clone to prevent mutation leaks
        const sanitized = {
          regime: state.regime,
          risk: state.risk,
          confidence: state.confidence,
          status: state.status,
          scope: state.scope
        };

        // Validate structure
        if (!REGIMES.includes(sanitized.regime)) {
          throw new Error("Invalid regime");
        }
        if (!RISK_LEVELS.includes(sanitized.risk)) {
          throw new Error("Invalid risk");
        }
        if (!CONFIDENCE_LEVELS.includes(sanitized.confidence)) {
          throw new Error("Invalid confidence");
        }
        if (sanitized.status !== "LIVE" && sanitized.status !== "UNKNOWN") {
          throw new Error("Invalid status");
        }
        if (sanitized.scope !== "PUBLIC" && sanitized.scope !== undefined) {
          throw new Error("Invalid scope");
        }

        return sanitized;

      } catch (err) {
        // Return fail-safe state
        return {
          regime: "UNKNOWN",
          risk: "NORMAL",
          confidence: "LOW",
          status: "UNKNOWN",
          scope: "PUBLIC"
        };
      }
    }

    /* ---- ARCHITECTURE: RENDER NAV (DOM Writes Only) ---- */
    function renderNAV(state) {
      try {
        const safeState = sanitizeForTier0(state);

        const navLine =
          `[NAV] REGIME: ${safeState.regime}` +
          ` | RISK: ${safeState.risk}` +
          ` | CONFIDENCE: ${safeState.confidence}` +
          ` | STATUS: ${safeState.status}` +
          ` | SCOPE: ${safeState.scope}`;

        navEl.textContent = navLine;

      } catch (err) {
        // Fail-safe render
        navEl.textContent = "[NAV] STATE: UNKNOWN";
      }
    }

    /* ---- ARCHITECTURE: RENDER STATUS (DOM Writes Only) ---- */
    function renderStatus() {
      try {
        const statusLine =
          `[STATUS] LIVE` +
          ` | SOURCE: PRESENT_STATE` +
          ` | MODE: READ_ONLY`;

        statusEl.textContent = statusLine;

      } catch (err) {
        // Fail-safe render
        statusEl.textContent = "[STATUS] OFFLINE";
      }
    }

    /* ---- FAIL-SAFE HANDLER ---- */
    function triggerFailSafe() {
      try {
        // Clear all output
        navEl.textContent = "";
        statusEl.textContent = "";

        // Render fail-safe state
        navEl.textContent = "[NAV] STATE: UNKNOWN";
        statusEl.textContent = "[STATUS] OFFLINE";

      } catch (err) {
        // Ultimate fail-safe: blank screen
        document.getElementById("terminal").innerHTML = "";
      }
    }

    /* ---- BOOT SEQUENCE (Static Render Only) ---- */
    (function init() {
      try {
        // Render static NAV packet through normal pipeline
        renderNAV(STATIC_NAV_PACKET);
        renderStatus();

      } catch (err) {
        triggerFailSafe();
      }
    })();

  </script>
</body>
</html>
