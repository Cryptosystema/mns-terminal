<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>MNS | Market Navigation System</title>
  <style>
    body {
      margin: 0;
      background: #000;
      color: #00ff66;
      font-family: "Courier New", monospace;
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
      overflow: hidden;
    }

    .terminal {
      width: 640px;
      height: 420px;
      border: 1px solid #00ff66;
      padding: 16px;
      box-sizing: border-box;
      overflow: hidden;
      box-shadow: 0 0 20px rgba(0,255,102,0.2);
      position: relative;
    }

    .line {
      white-space: pre;
      line-height: 1.35;
    }

    .dim {
      color: rgba(0,255,102,0.6);
    }
  </style>
</head>
<body>
  <div class="terminal" id="terminal"></div>

  <script>
    /* ================================
       Phase 9.6.1 — Tunnel Visualization Engine
       Phase 9.6.2 — Semantic Stream Structuring
       Phase 9.6.3 — Regime Signals (Pre-Risk, Non-Actionable)
       Phase 9.6.4 — Integrity Markers (Data Health & Silent Failure Detection)
       Phase 9.6.5 — Temporal Coherence (Clock Drift & Time Semantics)
       ================================ */

    /* ---------- Deterministic PRNG ---------- */
    function createPRNG(seed) {
      let s = seed >>> 0;
      return function () {
        s = (s * 1664525 + 1013904223) >>> 0;
        return s / 4294967296;
      };
    }
    const rand = createPRNG(9461);

    /* ---------- Global State ---------- */
    const TunnelState = {
      phase: "9.6",
      status: "STABLE",
      location: "TBILISI_HUB_01",
      depth: 72,
      nodes: [
        { id: "TBILISI_01", load: 0.71, status: "STABLE" }
      ],
      stream: {
        tick: 0,
        lastEvent: null
      },
      regime: {
        state: "CALM",
        confidence: 0.0,
        lastChangeTick: 0
      },
      integrity: {
        health: "OK",
        lastTick: 0,
        missedTicks: 0,
        checksum: 0,
        prevDepth: 72,
        prevLoad: 0.71,
        staleTicks: 0
      },
      time: {
        tick: 0,
        expectedInterval: 1,
        drift: 0,
        coherence: "LOCKED",
        lastCoherenceTick: 0,
        tickHistory: []
      }
    };

    /* ---------- Config ---------- */
    const TICK_MS = 900;
    const MAX_LINES = 120;
    const BAR_WIDTH = 12;
    const HEARTBEAT_INTERVAL = 7;
    const REGIME_HYSTERESIS = 3;
    const CONFIDENCE_THRESHOLDS = [0.6, 0.8];
    const INTEGRITY_HYSTERESIS = 3;
    const STALE_THRESHOLD = 5;
    const VALUE_EPSILON = 0.001;
    const TIME_HYSTERESIS = 4;
    const DRIFT_THRESHOLD_MINOR = 2;
    const DRIFT_THRESHOLD_MAJOR = 5;
    const TICK_HISTORY_SIZE = 10;

    /* ---------- Integrity Computation Logic ---------- */
    function computeIntegrity() {
      const tick = TunnelState.stream.tick;
      const depth = TunnelState.depth;
      const avgLoad = TunnelState.nodes.reduce((sum, n) => sum + n.load, 0) / TunnelState.nodes.length;
      const currentHealth = TunnelState.integrity.health;

      // Check tick continuity (expected: lastTick + 1 = tick)
      const expectedTick = TunnelState.integrity.lastTick + 1;
      if (tick !== expectedTick && TunnelState.integrity.lastTick > 0) {
        TunnelState.integrity.missedTicks++;
      }
      TunnelState.integrity.lastTick = tick;

      // Check value continuity (detect frozen values)
      const depthChange = Math.abs(depth - TunnelState.integrity.prevDepth);
      const loadChange = Math.abs(avgLoad - TunnelState.integrity.prevLoad);
      
      if (depthChange < VALUE_EPSILON && loadChange < VALUE_EPSILON) {
        TunnelState.integrity.staleTicks++;
      } else {
        TunnelState.integrity.staleTicks = 0;
      }

      TunnelState.integrity.prevDepth = depth;
      TunnelState.integrity.prevLoad = avgLoad;

      // Compute rolling checksum (simple hash over key state fields)
      const checksumInput = Math.floor(depth * 1000) + Math.floor(avgLoad * 10000) + tick;
      TunnelState.integrity.checksum = (TunnelState.integrity.checksum * 31 + checksumInput) >>> 0;

      // Determine health state with hysteresis
      let targetHealth = "OK";
      
      if (TunnelState.integrity.staleTicks >= STALE_THRESHOLD || TunnelState.integrity.missedTicks >= 5) {
        targetHealth = "STALE";
      } else if (TunnelState.integrity.missedTicks >= 2 || TunnelState.integrity.staleTicks >= 3) {
        targetHealth = "DEGRADED";
      }

      // Apply hysteresis to prevent rapid flipping
      let integrityChanged = false;
      if (targetHealth !== currentHealth) {
        // Only transition after sustained condition
        const ticksSinceLastChange = tick - (TunnelState.integrity.lastHealthChangeTick || 0);
        if (!TunnelState.integrity.lastHealthChangeTick || ticksSinceLastChange >= INTEGRITY_HYSTERESIS) {
          TunnelState.integrity.health = targetHealth;
          TunnelState.integrity.lastHealthChangeTick = tick;
          integrityChanged = true;
        }
      } else {
        TunnelState.integrity.lastHealthChangeTick = tick;
      }

      return integrityChanged;
    }

    /* ---------- Temporal Coherence Computation Logic ---------- */
    function computeTemporalCoherence() {
      const tick = TunnelState.stream.tick;
      const currentCoherence = TunnelState.time.coherence;

      // Increment internal time tick
      TunnelState.time.tick++;

      // Track tick intervals in history
      const prevTick = TunnelState.time.tickHistory.length > 0 
        ? TunnelState.time.tickHistory[TunnelState.time.tickHistory.length - 1]
        : TunnelState.time.tick - 1;
      
      const interval = TunnelState.time.tick - prevTick;
      TunnelState.time.tickHistory.push(TunnelState.time.tick);
      
      // Keep history bounded
      if (TunnelState.time.tickHistory.length > TICK_HISTORY_SIZE) {
        TunnelState.time.tickHistory.shift();
      }

      // Calculate drift: deviation from expected interval
      const deviation = interval - TunnelState.time.expectedInterval;
      
      // Accumulate drift with decay
      TunnelState.time.drift = TunnelState.time.drift * 0.7 + deviation * 0.3;

      // Determine target coherence state based on accumulated drift
      let targetCoherence = "LOCKED";
      const absDrift = Math.abs(TunnelState.time.drift);
      
      if (absDrift >= DRIFT_THRESHOLD_MAJOR) {
        targetCoherence = "DESYNC";
      } else if (absDrift >= DRIFT_THRESHOLD_MINOR) {
        targetCoherence = "DRIFTING";
      }

      // Apply hysteresis to prevent rapid state changes
      let coherenceChanged = false;
      if (targetCoherence !== currentCoherence) {
        const ticksSinceLastChange = tick - (TunnelState.time.lastCoherenceTick || 0);
        if (!TunnelState.time.lastCoherenceTick || ticksSinceLastChange >= TIME_HYSTERESIS) {
          TunnelState.time.coherence = targetCoherence;
          TunnelState.time.lastCoherenceTick = tick;
          coherenceChanged = true;
        }
      } else {
        TunnelState.time.lastCoherenceTick = tick;
      }

      return coherenceChanged;
    }

    /* ---------- Regime Computation Logic ---------- */
    function computeRegime() {
      const depth = TunnelState.depth;
      const avgLoad = TunnelState.nodes.reduce((sum, n) => sum + n.load, 0) / TunnelState.nodes.length;
      const tick = TunnelState.stream.tick;
      const currentState = TunnelState.regime.state;

      // Determine target regime based on telemetry
      let targetState;
      if (depth > 85 || avgLoad > 0.80) {
        targetState = "COMPRESSED";
      } else if (depth >= 70 || avgLoad >= 0.65) {
        targetState = "ELEVATED";
      } else {
        targetState = "CALM";
      }

      // Apply hysteresis: require sustained condition before transition
      const ticksSinceChange = tick - TunnelState.regime.lastChangeTick;
      let shouldTransition = false;

      if (targetState !== currentState) {
        // Check if we've been in "wanting to change" state long enough
        if (ticksSinceChange >= REGIME_HYSTERESIS) {
          shouldTransition = true;
        }
      }

      // Determine if regime changed
      let regimeChanged = false;
      if (shouldTransition) {
        TunnelState.regime.state = targetState;
        TunnelState.regime.lastChangeTick = tick;
        TunnelState.regime.confidence = 0.0;
        regimeChanged = true;
      }

      // Update confidence: increases with time in stable regime
      if (targetState === currentState && !regimeChanged) {
        const confidenceGrowthRate = 0.08;
        TunnelState.regime.confidence = Math.min(
          1.0,
          TunnelState.regime.confidence + confidenceGrowthRate
        );
      }

      return regimeChanged;
    }

    /* ---------- State Update Logic ---------- */
    function updateState() {
      // Increment stream tick
      TunnelState.stream.tick++;

      // Node load drift (smooth, bounded)
      TunnelState.nodes.forEach(node => {
        const drift = (rand() - 0.5) * 0.06;
        node.load = Math.min(1, Math.max(0, node.load + drift));
        node.status = "STABLE";
      });

      // Tunnel depth drift
      const depthDrift = (rand() - 0.5) * 2;
      TunnelState.depth = Math.min(
        100,
        Math.max(0, TunnelState.depth + depthDrift)
      );

      // Event detection: depth threshold crossing
      if (TunnelState.depth >= 85 && TunnelState.stream.lastEvent !== "DEPTH_HIGH") {
        TunnelState.stream.lastEvent = "DEPTH_HIGH";
      } else if (TunnelState.depth < 85 && TunnelState.stream.lastEvent === "DEPTH_HIGH") {
        TunnelState.stream.lastEvent = "DEPTH_NORMAL";
      }

      // Event detection: load spike
      const avgLoad = TunnelState.nodes.reduce((sum, n) => sum + n.load, 0) / TunnelState.nodes.length;
      if (avgLoad >= 0.80 && TunnelState.stream.lastEvent !== "LOAD_SPIKE") {
        TunnelState.stream.lastEvent = "LOAD_SPIKE";
      } else if (avgLoad < 0.80 && TunnelState.stream.lastEvent === "LOAD_SPIKE") {
        TunnelState.stream.lastEvent = "LOAD_NOMINAL";
      }
    }

    /* ---------- Render Helpers ---------- */
    function depthBar(depth) {
      const filled = Math.round((depth / 100) * BAR_WIDTH);
      const empty = BAR_WIDTH - filled;
      return (
        "[" +
        "█".repeat(filled) +
        "░".repeat(empty) +
        `] ${Math.round(depth)}%`
      );
    }

    function formatStreamLine(type, content) {
      return `[${type.padEnd(11)}] ${content}`;
    }

    function generateTelemetryLines() {
      const lines = [];
      const node = TunnelState.nodes[0];
      lines.push(
        formatStreamLine(
          "TELEMETRY",
          `NODE ${node.id} | LOAD ${node.load.toFixed(2)} | ${node.status}`
        )
      );
      lines.push(
        formatStreamLine(
          "TELEMETRY",
          `TUNNEL DEPTH ${depthBar(TunnelState.depth)}`
        )
      );
      return lines;
    }

    function generateHeartbeatLine() {
      return formatStreamLine("HEARTBEAT", "sync ok | latency stable");
    }

    function generateEventLine() {
      const event = TunnelState.stream.lastEvent;
      if (!event) return null;

      switch (event) {
        case "DEPTH_HIGH":
          return formatStreamLine("EVENT", "depth threshold approaching 90%");
        case "DEPTH_NORMAL":
          return formatStreamLine("EVENT", "depth returned to nominal range");
        case "LOAD_SPIKE":
          return formatStreamLine("EVENT", "load spike detected across nodes");
        case "LOAD_NOMINAL":
          return formatStreamLine("EVENT", "load stabilized to nominal levels");
        default:
          return null;
      }
    }

    function generateRegimeLine() {
      const regime = TunnelState.regime;
      return formatStreamLine(
        "REGIME",
        `state=${regime.state} | confidence=${regime.confidence.toFixed(2)}`
      );
    }

    function generateIntegrityLine() {
      const integrity = TunnelState.integrity;
      return formatStreamLine(
        "INTEGRITY",
        `health=${integrity.health} | missedTicks=${integrity.missedTicks}`
      );
    }

    function generateTimeLine() {
      const time = TunnelState.time;
      const driftStr = time.drift >= 0 
        ? `+${time.drift.toFixed(1)}`
        : time.drift.toFixed(1);
      return formatStreamLine(
        "TIME",
        `coherence=${time.coherence} | drift=${driftStr}`
      );
    }

    /* ---------- Render Logic ---------- */
    function render(terminal) {
      const fragment = document.createDocumentFragment();
      const tick = TunnelState.stream.tick;
      
      // Track previous confidence for threshold crossing detection
      const prevConfidence = TunnelState.regime.confidence;

      // Compute temporal coherence (isolated)
      const timeChanged = computeTemporalCoherence();

      // Compute integrity (isolated)
      const integrityChanged = computeIntegrity();

      // Compute regime (isolated)
      const regimeChanged = computeRegime();

      // Detect confidence threshold crossings
      let confidenceThresholdCrossed = false;
      for (const threshold of CONFIDENCE_THRESHOLDS) {
        if (prevConfidence < threshold && TunnelState.regime.confidence >= threshold) {
          confidenceThresholdCrossed = true;
          break;
        }
      }

      // Heartbeat line (every N ticks)
      if (tick % HEARTBEAT_INTERVAL === 0) {
        const heartbeat = document.createElement("div");
        heartbeat.className = "line dim";
        heartbeat.textContent = generateHeartbeatLine();
        fragment.appendChild(heartbeat);
      }

      // Time line (on coherence state transition)
      if (timeChanged) {
        const timeLine = document.createElement("div");
        timeLine.className = "line dim";
        timeLine.textContent = generateTimeLine();
        fragment.appendChild(timeLine);
      }

      // Integrity line (on health state transition)
      if (integrityChanged) {
        const integrityLine = document.createElement("div");
        integrityLine.className = "line dim";
        integrityLine.textContent = generateIntegrityLine();
        fragment.appendChild(integrityLine);
      }

      // Regime line (on state change or confidence threshold crossing)
      if (regimeChanged || confidenceThresholdCrossed) {
        const regimeLine = document.createElement("div");
        regimeLine.className = "line dim";
        regimeLine.textContent = generateRegimeLine();
        fragment.appendChild(regimeLine);
      }

      // Telemetry lines (every tick)
      const telemetryLines = generateTelemetryLines();
      telemetryLines.forEach(text => {
        const line = document.createElement("div");
        line.className = "line";
        line.textContent = text;
        fragment.appendChild(line);
      });

      // Event line (on state transition)
      const eventText = generateEventLine();
      if (eventText) {
        const eventLine = document.createElement("div");
        eventLine.className = "line";
        eventLine.textContent = eventText;
        fragment.appendChild(eventLine);
        
        // Clear event after rendering to prevent repeats
        TunnelState.stream.lastEvent = null;
      }

      terminal.appendChild(fragment);

      // Line cap
      while (terminal.children.length > MAX_LINES) {
        terminal.removeChild(terminal.firstChild);
      }

      // Auto-scroll
      terminal.scrollTop = terminal.scrollHeight;
    }

    /* ---------- Boot Sequence ---------- */
    (function init() {
      const terminal = document.getElementById("terminal");

      const header = [
        formatStreamLine("SYSTEM", "MNS (Market Navigation System)"),
        formatStreamLine("SYSTEM", `Phase ${TunnelState.phase} active — tunnel initialized`),
        formatStreamLine("SYSTEM", `Location: ${TunnelState.location}`),
        formatStreamLine("SYSTEM", "Connection: SECURE_ENCRYPTED"),
        formatStreamLine("SYSTEM", "Access: RESTRICTED_TO_PILOTS"),
        ""
      ];

      header.forEach(text => {
        const line = document.createElement("div");
        line.className = "line";
        line.textContent = text;
        terminal.appendChild(line);
      });

      setInterval(() => {
        updateState();
        render(terminal);
      }, TICK_MS);
    })();
  </script>
</body>
</html>
