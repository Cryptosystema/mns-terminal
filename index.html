<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>MNS | Market Navigation System</title>
  <style>
    body {
      margin: 0;
      background: #000;
      color: #00ff66;
      font-family: "Courier New", monospace;
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
      overflow: hidden;
    }

    .terminal {
      width: 640px;
      height: 420px;
      border: 1px solid #00ff66;
      padding: 16px;
      box-sizing: border-box;
      overflow: hidden;
      box-shadow: 0 0 20px rgba(0,255,102,0.2);
      position: relative;
    }

    .line {
      white-space: pre;
      line-height: 1.35;
    }

    .dim {
      color: rgba(0,255,102,0.6);
    }
  </style>
</head>
<body>
  <div class="terminal" id="terminal"></div>

  <script>
    /* ================================
       Phase 9.6.1 — Tunnel Visualization Engine
       Phase 9.6.2 — Semantic Stream Structuring
       Phase 9.6.3 — Regime Signals (Pre-Risk, Non-Actionable)
       ================================ */

    /* ---------- Deterministic PRNG ---------- */
    function createPRNG(seed) {
      let s = seed >>> 0;
      return function () {
        s = (s * 1664525 + 1013904223) >>> 0;
        return s / 4294967296;
      };
    }
    const rand = createPRNG(9461);

    /* ---------- Global State ---------- */
    const TunnelState = {
      phase: "9.6",
      status: "STABLE",
      location: "TBILISI_HUB_01",
      depth: 72,
      nodes: [
        { id: "TBILISI_01", load: 0.71, status: "STABLE" }
      ],
      stream: {
        tick: 0,
        lastEvent: null
      },
      regime: {
        state: "CALM",
        confidence: 0.0,
        lastChangeTick: 0
      }
    };

    /* ---------- Config ---------- */
    const TICK_MS = 900;
    const MAX_LINES = 120;
    const BAR_WIDTH = 12;
    const HEARTBEAT_INTERVAL = 7;
    const REGIME_HYSTERESIS = 3; // ticks before regime locks in
    const CONFIDENCE_THRESHOLDS = [0.6, 0.8];

    /* ---------- Regime Computation Logic ---------- */
    function computeRegime() {
      const depth = TunnelState.depth;
      const avgLoad = TunnelState.nodes.reduce((sum, n) => sum + n.load, 0) / TunnelState.nodes.length;
      const tick = TunnelState.stream.tick;
      const currentState = TunnelState.regime.state;

      // Determine target regime based on telemetry
      let targetState;
      if (depth > 85 || avgLoad > 0.80) {
        targetState = "COMPRESSED";
      } else if (depth >= 70 || avgLoad >= 0.65) {
        targetState = "ELEVATED";
      } else {
        targetState = "CALM";
      }

      // Apply hysteresis: require sustained condition before transition
      const ticksSinceChange = tick - TunnelState.regime.lastChangeTick;
      let shouldTransition = false;

      if (targetState !== currentState) {
        // Check if we've been in "wanting to change" state long enough
        if (ticksSinceChange >= REGIME_HYSTERESIS) {
          shouldTransition = true;
        }
      }

      // Determine if regime changed
      let regimeChanged = false;
      if (shouldTransition) {
        TunnelState.regime.state = targetState;
        TunnelState.regime.lastChangeTick = tick;
        TunnelState.regime.confidence = 0.0;
        regimeChanged = true;
      }

      // Update confidence: increases with time in stable regime
      if (targetState === currentState && !regimeChanged) {
        const confidenceGrowthRate = 0.08;
        TunnelState.regime.confidence = Math.min(
          1.0,
          TunnelState.regime.confidence + confidenceGrowthRate
        );
      }

      return regimeChanged;
    }

    /* ---------- State Update Logic ---------- */
    function updateState() {
      // Increment stream tick
      TunnelState.stream.tick++;

      // Node load drift (smooth, bounded)
      TunnelState.nodes.forEach(node => {
        const drift = (rand() - 0.5) * 0.06;
        node.load = Math.min(1, Math.max(0, node.load + drift));
        node.status = "STABLE";
      });

      // Tunnel depth drift
      const depthDrift = (rand() - 0.5) * 2;
      TunnelState.depth = Math.min(
        100,
        Math.max(0, TunnelState.depth + depthDrift)
      );

      // Event detection: depth threshold crossing
      if (TunnelState.depth >= 85 && TunnelState.stream.lastEvent !== "DEPTH_HIGH") {
        TunnelState.stream.lastEvent = "DEPTH_HIGH";
      } else if (TunnelState.depth < 85 && TunnelState.stream.lastEvent === "DEPTH_HIGH") {
        TunnelState.stream.lastEvent = "DEPTH_NORMAL";
      }

      // Event detection: load spike
      const avgLoad = TunnelState.nodes.reduce((sum, n) => sum + n.load, 0) / TunnelState.nodes.length;
      if (avgLoad >= 0.80 && TunnelState.stream.lastEvent !== "LOAD_SPIKE") {
        TunnelState.stream.lastEvent = "LOAD_SPIKE";
      } else if (avgLoad < 0.80 && TunnelState.stream.lastEvent === "LOAD_SPIKE") {
        TunnelState.stream.lastEvent = "LOAD_NOMINAL";
      }
    }

    /* ---------- Render Helpers ---------- */
    function depthBar(depth) {
      const filled = Math.round((depth / 100) * BAR_WIDTH);
      const empty = BAR_WIDTH - filled;
      return (
        "[" +
        "█".repeat(filled) +
        "░".repeat(empty) +
        `] ${Math.round(depth)}%`
      );
    }

    function formatStreamLine(type, content) {
      return `[${type.padEnd(11)}] ${content}`;
    }

    function generateTelemetryLines() {
      const lines = [];
      const node = TunnelState.nodes[0];
      lines.push(
        formatStreamLine(
          "TELEMETRY",
          `NODE ${node.id} | LOAD ${node.load.toFixed(2)} | ${node.status}`
        )
      );
      lines.push(
        formatStreamLine(
          "TELEMETRY",
          `TUNNEL DEPTH ${depthBar(TunnelState.depth)}`
        )
      );
      return lines;
    }

    function generateHeartbeatLine() {
      return formatStreamLine("HEARTBEAT", "sync ok | latency stable");
    }

    function generateEventLine() {
      const event = TunnelState.stream.lastEvent;
      if (!event) return null;

      switch (event) {
        case "DEPTH_HIGH":
          return formatStreamLine("EVENT", "depth threshold approaching 90%");
        case "DEPTH_NORMAL":
          return formatStreamLine("EVENT", "depth returned to nominal range");
        case "LOAD_SPIKE":
          return formatStreamLine("EVENT", "load spike detected across nodes");
        case "LOAD_NOMINAL":
          return formatStreamLine("EVENT", "load stabilized to nominal levels");
        default:
          return null;
      }
    }

    function generateRegimeLine() {
      const regime = TunnelState.regime;
      return formatStreamLine(
        "REGIME",
        `state=${regime.state} | confidence=${regime.confidence.toFixed(2)}`
      );
    }

    /* ---------- Render Logic ---------- */
    function render(terminal) {
      const fragment = document.createDocumentFragment();
      const tick = TunnelState.stream.tick;
      
      // Track previous confidence for threshold crossing detection
      const prevConfidence = TunnelState.regime.confidence;

      // Compute regime (isolated)
      const regimeChanged = computeRegime();

      // Detect confidence threshold crossings
      let confidenceThresholdCrossed = false;
      for (const threshold of CONFIDENCE_THRESHOLDS) {
        if (prevConfidence < threshold && TunnelState.regime.confidence >= threshold) {
          confidenceThresholdCrossed = true;
          break;
        }
      }

      // Heartbeat line (every N ticks)
      if (tick % HEARTBEAT_INTERVAL === 0) {
        const heartbeat = document.createElement("div");
        heartbeat.className = "line dim";
        heartbeat.textContent = generateHeartbeatLine();
        fragment.appendChild(heartbeat);
      }

      // Regime line (on state change or confidence threshold crossing)
      if (regimeChanged || confidenceThresholdCrossed) {
        const regimeLine = document.createElement("div");
        regimeLine.className = "line dim";
        regimeLine.textContent = generateRegimeLine();
        fragment.appendChild(regimeLine);
      }

      // Telemetry lines (every tick)
      const telemetryLines = generateTelemetryLines();
      telemetryLines.forEach(text => {
        const line = document.createElement("div");
        line.className = "line";
        line.textContent = text;
        fragment.appendChild(line);
      });

      // Event line (on state transition)
      const eventText = generateEventLine();
      if (eventText) {
        const eventLine = document.createElement("div");
        eventLine.className = "line";
        eventLine.textContent = eventText;
        fragment.appendChild(eventLine);
        
        // Clear event after rendering to prevent repeats
        TunnelState.stream.lastEvent = null;
      }

      terminal.appendChild(fragment);

      // Line cap
      while (terminal.children.length > MAX_LINES) {
        terminal.removeChild(terminal.firstChild);
      }

      // Auto-scroll
      terminal.scrollTop = terminal.scrollHeight;
    }

    /* ---------- Boot Sequence ---------- */
    (function init() {
      const terminal = document.getElementById("terminal");

      const header = [
        formatStreamLine("SYSTEM", "MNS (Market Navigation System)"),
        formatStreamLine("SYSTEM", `Phase ${TunnelState.phase} active — tunnel initialized`),
        formatStreamLine("SYSTEM", `Location: ${TunnelState.location}`),
        formatStreamLine("SYSTEM", "Connection: SECURE_ENCRYPTED"),
        formatStreamLine("SYSTEM", "Access: RESTRICTED_TO_PILOTS"),
        ""
      ];

      header.forEach(text => {
        const line = document.createElement("div");
        line.className = "line";
        line.textContent = text;
        terminal.appendChild(line);
      });

      setInterval(() => {
        updateState();
        render(terminal);
      }, TICK_MS);
    })();
  </script>
</body>
</html>
